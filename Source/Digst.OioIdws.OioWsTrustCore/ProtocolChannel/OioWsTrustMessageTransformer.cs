using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.Caching;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel.Channels;
using System.ServiceModel.Security;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using Digst.OioIdws.CommonCore;
using Digst.OioIdws.CommonCore.Constants;
using Digst.OioIdws.CommonCore.Logging;
using Digst.OioIdws.OioWsTrustCore.Utils;

namespace Digst.OioIdws.OioWsTrustCore.ProtocolChannel
{
    /// <summary>
    /// This class implements the signature case part of specification [KOMBIT-STS].
    /// It expects a standard WS-Trust message and transforms it to a format that KOMBIT STS understands and vice versa.
    /// The specification requires SOAP 1.2 to be used
    /// <S12:Envelope>
    ///     <S12:Header>
    ///         <wsa:Action>...</wsa:Action>
    ///         <wsa:MessageID>...</wsa:MessageID>
    ///         <wsa:To>...</wsa:To>
    ///         <wsse:Security>...</wsse:Security>
    ///     </S12:Header>
    ///     <S12:Body>
    ///         <wst:RequestSecurityToken>
    ///             <wst13:OnBehalfOf>...</wst13:OnBehalfOf> - Only present in OnBehalfOf use case scenario
    ///             <wst:RequestType>...</wst:RequestType>
    ///             <wsp:AppliesTo>...</wsp:AppliesTo>
    ///         </wst:RequestSecurityToken>
    ///     </S12:Body>
    /// </S12:Envelope>
    /// </summary>
    public class OioWsTrustMessageTransformer : IOioWsTrustMessageTransformer
    {
        private readonly StsTokenServiceConfiguration _configuration;

        /// <summary>
        /// Creates a new instance of OioWsTrustMessageTransformer
        /// </summary>
        /// <param name="configuration">The STS configuration</param>
        public OioWsTrustMessageTransformer(StsTokenServiceConfiguration configuration)
        {
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
        }

        /// <summary>
        /// The RST message that is generated by .NET does not satisfy OioWsTrust and KOMBIT STS profiles.
        /// This method modifies the message to make it satisfy those profiles
        /// </summary>
        /// <param name="request">The input RST message</param>
        /// <returns>The output RST message that satisfies all requirements</returns>
        public Message ModifyMessageAccordingToStsNeeds(Message request)
        {
            // Convert Message into a XML document that can be manipulated
            var xDocument = request.ToXml();

            // Log RST before being manipulated ... if we do not take the above two headers into account :)
            Logger.Instance.Trace("RST send to STS before being manipulated:\n" + xDocument);

            // Manipulate XML
            AddNamespacesToEnvelope(xDocument);
            ManipulateHeader(xDocument);
            ManipulateBody(xDocument);
            xDocument = SignMessage(xDocument, _configuration.ClientCertificate);

            // Log RST after being manipulated
            Logger.Instance.Trace("RST send to STS after being manipulated:\n" + xDocument);

            // Convert XML back to a Message
            return xDocument.ToMessage(request);
        }

        /// <summary>
        /// Validate the response's signature, check mandatory elements, and correct the Security header
        /// </summary>
        /// <param name="response">The response from STS</param>
        /// <param name="matchedMessageId">The unique message Id to validate against the Response's RelatesTo</param>
        /// <returns></returns>
        public Message ValidateAndModifyMessageAccordingToWsTrust(Message response, UniqueId matchedMessageId)
        {
            // Convert Message into a XML document that can be manipulated
            var xDocument = response.ToXml();

            // Log RSTR before being manipulated
            Logger.Instance.Trace("RSTR received from STS before being manipulated:\n" + xDocument);

            // Fault response from KOMBIT is a standard one as SOAP 1.2 spec, seem nothing to manipulate
            if (!response.IsFault)
            {
                // validate  Rstr
                ValidateRstr(xDocument, response, matchedMessageId);
            }

            // Log RSTR before being manipulated
            Logger.Instance.Trace("RSTR received from STS after being manipulated:\n" + xDocument);

            // Convert XML back to a Message
            var result = xDocument.ToMessage(response);

            // Security header element is marked with the MustUnderstand attribute. Hence, we need to inform the WCF framework that this header element has been taken care of.
            // A Fault response does not have "Security" header
            var securityHeader = result.Headers.SingleOrDefault(x => "Security" == x.Name && Namespaces.Wsse10Namespace == x.Namespace);
            if (securityHeader != null)
            {
                result.Headers.UnderstoodHeaders.Add(securityHeader);
            }

            return result;
        }

        /// <summary>
        /// NemLogin STS doesn't have a strict datetime format, therefore we patch it ourselves to remove variant millisecond component
        /// </summary>
        /// <param name="dateTimeString"></param>
        /// <returns></returns>
        private static DateTime GetPatchedDateTime(string dateTimeString)
        {
            var index = dateTimeString.IndexOf(".", StringComparison.Ordinal);
            if (index != -1)
            {
                dateTimeString = dateTimeString.Substring(0, index) + "Z";
            }

            return DateTime.ParseExact(dateTimeString, Common.DateTimeFormat, CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal);
        }

        private static void AddNamespacesToEnvelope(XDocument xDocument)
        {
            var namespaceManager = new XmlNamespaceManager(new NameTable());
            namespaceManager.AddNamespace("s", Namespaces.S12Namespace);
            var envelopeElement = xDocument.XPathSelectElement("/s:Envelope", namespaceManager);

            // This namespace is required. If not added then Id attributes is not correctly prefixed with "wsu" and RST becomes invalid according to standard.
            envelopeElement.Add(new XAttribute(XNamespace.Xmlns + Namespaces.WsuPrefix, Namespaces.WsuNamespace));
        }

        private void ManipulateHeader(XDocument xDocument)
        {
            XmlNamespaceManager namespaceManager = CreateXmlNamespaceManagerForRequestHeader();

            // The spec states that all header elements (also those not used by the STS) must be included in the signature. Hence, we need to remove the debugger element.
            // Remove VS debugger element. It is only present when running in debug mode. So removing the element is just to make life easier for developers.
            xDocument.RemoveIfExist("/s:Envelope/s:Header/vs:VsDebuggerCausalityData", namespaceManager);

            // Remove Diagnostics tracing element. It is only present when WCF Diagnostics are enabled. So removing the element is just to make life easier for developers.
            xDocument.RemoveIfExist("/s:Envelope/s:Header/vcf:ActivityId", namespaceManager);

            // Because ManuelAddressing is set to true we need to manual add the messageID header
            var actionElement = xDocument.XPathSelectElement("/s:Envelope/s:Header/a:Action", namespaceManager);
            var messageIdElement = new XElement(XName.Get(WsAddressing.WsAddressingMessageId, Namespaces.WsaNamespace));
            messageIdElement.Value = "uuid:" + Guid.NewGuid().ToString("D");
            actionElement.AddAfterSelf(messageIdElement);

            // a:To is normally set to the URI of the service endpoint by the framework which is not what we need here and therefore we neeed to set it manually.
            // In order to work ... ManualAddressing must be set to true on HttpsTransportBindingElement or else the a:To is overwritten in the HttpsTransportChannel.
            var toElement = new XElement(XName.Get(WsAddressing.WsAddressingTo, Namespaces.WsaNamespace));
            toElement.Value = _configuration.StsConfiguration.EndpointAddress;
            messageIdElement.AddAfterSelf(toElement);

            // Add Security element
            var headerElement = xDocument.XPathSelectElement("/s:Envelope/s:Header", namespaceManager);
            headerElement.Add(BuildSecurityElement());
        }

        private static XmlNamespaceManager CreateXmlNamespaceManagerForRequestHeader()
        {
            var namespaceManager = new XmlNamespaceManager(new NameTable());
            namespaceManager.AddNamespace("a", Namespaces.WsaNamespace);
            namespaceManager.AddNamespace("s", Namespaces.S12Namespace);
            namespaceManager.AddNamespace("vs", Namespaces.VsDebuggerNamespace);
            namespaceManager.AddNamespace("vcf", Namespaces.WcfDiagnosticsNamespace);
            namespaceManager.AddNamespace("wst13", Namespaces.Wst13Namespace);
            namespaceManager.AddNamespace("wst14", Namespaces.Wst14Namespace);
            return namespaceManager;
        }

        private void ManipulateBody(XDocument xDocument)
        {
            XmlNamespaceManager namespaceManager = CreateXmlNamespaceManagerForRequestBody();

            // Remove entropy element
            xDocument.RemoveIfExist("/s:Envelope/s:Body/trust:RequestSecurityToken/trust:Entropy", namespaceManager);

            // Remove last '/' in endpoint address. Due to new URI(...) automatically adds an ending '/'.
            var addressReferenceElement = xDocument.XPathSelectElement("/s:Envelope/s:Body/trust:RequestSecurityToken/wsp:AppliesTo/wsa:EndpointReference/wsa:Address", namespaceManager);
            RemoveEndingForwardSlash(addressReferenceElement);

            // Change lifetime expires format if present from "yyyy-MM-ddTHH:mm:ss.fffZ" to "yyyy-MM-ddTHH:mm:ssZ"
            var lifetimeElement = xDocument.XPathSelectElement("/s:Envelope/s:Body/trust:RequestSecurityToken/trust:Lifetime/wsu:Expires", namespaceManager);
            if (lifetimeElement != null)
            {
                lifetimeElement.Value = GetPatchedDateTime(lifetimeElement.Value).ToString(Common.DateTimeFormat, CultureInfo.InvariantCulture);
            }

            // Add Issuer
            AddIssuerToRequest(xDocument, namespaceManager);
        }

        private void AddIssuerToRequest(XDocument xDocument, XmlNamespaceManager namespaceManager)
        {
            var issuerElement = xDocument.XPathSelectElement("/s:Envelope/s:Body/trust:RequestSecurityToken/trust:Issuer", namespaceManager);
            if (issuerElement == null)
            {
                issuerElement = new XElement(XName.Get("Issuer", Namespaces.Wst13Namespace));
                var endpointRefElement = new XElement(XName.Get("EndpointReference", Namespaces.WsaNamespace));
                endpointRefElement.Add(new XElement(XName.Get("Address", Namespaces.WsaNamespace), _configuration.StsConfiguration.EntityIdentifier));
                issuerElement.Add(endpointRefElement);

                var requestSecurityTokenElement = xDocument.XPathSelectElement("/s:Envelope/s:Body/trust:RequestSecurityToken", namespaceManager);
                requestSecurityTokenElement.Add(issuerElement);
            }
        }

        private static XmlNamespaceManager CreateXmlNamespaceManagerForRequestBody()
        {
            var namespaceManager = new XmlNamespaceManager(new NameTable());
            namespaceManager.AddNamespace("wsp12", Namespaces.Wsp12Namespace);
            namespaceManager.AddNamespace("s", Namespaces.S12Namespace);
            namespaceManager.AddNamespace("wsa", Namespaces.WsaNamespace);
            namespaceManager.AddNamespace("trust", Namespaces.Wst13Namespace);
            namespaceManager.AddNamespace("wsp", Namespaces.Wsp12Namespace);
            namespaceManager.AddNamespace("wsu", Namespaces.WsuNamespace);
            return namespaceManager;
        }

        private void ValidateRstr(XDocument xDocument, Message response, UniqueId matchedMessageId)
        {
            XmlNamespaceManager namespaceManager = CreateXmlNamespaceManagerForResponse();

            // Verify signature before making any modifications
            if (!XmlSignatureUtils.VerifySignature(xDocument, _configuration.StsConfiguration.Certificate))
            {
                Logger.Instance.Error($"Failed to validate (using the certificate '{_configuration.StsConfiguration.Certificate.Thumbprint}') the SOAP signature received from STS!");
                throw new MessageSecurityException("SOAP signature received from STS does not validate!");
            }

            ValidateRelatesTo(response, matchedMessageId);
            DateTime messageExpireZuluTime = ValidateTimestamp(xDocument, namespaceManager);

            ValidateReplayAttack(xDocument, namespaceManager, messageExpireZuluTime);
        }

        private static DateTime ValidateTimestamp(XDocument xDocument, XmlNamespaceManager namespaceManager)
        {
            var messageExpireTimeElement = xDocument.XPathSelectElement("/s:Envelope/s:Header/wsse:Security/wsu:Timestamp/wsu:Expires", namespaceManager);
            var messageExpireZuluTime = GetPatchedDateTime(messageExpireTimeElement.Value);

            // Expiry time is currently not on the format specified by the spec. The spec says yyyy-MM-ddTHH:mm:ssZ but yyyy-MM-ddTHH:mm:ss.fffZ is currently retrieved.
            // Verify life time of SOAP message
            var currentZuluTime = DateTime.UtcNow;
            if (currentZuluTime >= messageExpireZuluTime)
            {
                Logger.Instance.Error($"SOAP message has expired. Current Zulu time was: {currentZuluTime}, message Zulu expiry time was: {messageExpireZuluTime}");
                throw new MessageSecurityException($"SOAP message has expired. Current Zulu time was: {currentZuluTime}, message Zulu expiry time was: {messageExpireZuluTime}");
            }

            // Verify life time of RSTS
            var rstsExpireTimeElement = xDocument.XPathSelectElement("/s:Envelope/s:Body/wst:RequestSecurityTokenResponseCollection/wst:RequestSecurityTokenResponse/wst:Lifetime/wsu:Expires", namespaceManager);
            var rstsExpireZuluTime = GetPatchedDateTime(rstsExpireTimeElement.Value);
            if (currentZuluTime >= rstsExpireZuluTime)
            {
                Logger.Instance.Error($"RSTS has expired. Current Zulu time was: {currentZuluTime}, RSTS Zulu expiry time was: {rstsExpireZuluTime}");
                throw new MessageSecurityException($"RSTS has expired. Current Zulu time was: {currentZuluTime}, RSTS Zulu expiry time was: {rstsExpireZuluTime}");
            }

            return messageExpireZuluTime;
        }

        private void ValidateReplayAttack(XDocument xDocument, XmlNamespaceManager namespaceManager, DateTime messageExpireZuluTime)
        {
            var signatureValueElement = xDocument.XPathSelectElement("/s:Envelope/s:Header/wsse:Security/d:Signature/d:SignatureValue", namespaceManager);
            if (_configuration.ReplayAttackCache.DoesKeyExist(signatureValueElement.Value))
            {
                var relatesToElement = xDocument.XPathSelectElement("/s:Envelope/s:Header/wsa:RelatesTo",
                    namespaceManager);
                Logger.Instance.Error($"Replay attack detected. Response of message with id: {relatesToElement.Value}, Signature: {signatureValueElement.Value}");
                throw new MessageSecurityException("Replay attack detected. Response of message with id: " + relatesToElement.Value);
            }
            else
            {
                _configuration.ReplayAttackCache.Set(signatureValueElement.Value, messageExpireZuluTime);
            }
        }

        private static void ValidateRelatesTo(Message response, UniqueId matchedMessageId)
        {
            // RelatesTo of the response must match MessageId of the request
            if (matchedMessageId != response.Headers.RelatesTo)
            {
                Logger.Instance.Error($"RelatesTo header block is required and its value ({response.Headers.RelatesTo}) MUST be set to the value of the <wsa:MessageID> header block ({matchedMessageId}) of the prior-received message.");
                throw new MessageSecurityException("RelatesTo header block is required and its value MUST be set to the value of the <wsa:MessageID> header block of the prior-received message.");
            }
        }

        private static XmlNamespaceManager CreateXmlNamespaceManagerForResponse()
        {
            var namespaceManager = new XmlNamespaceManager(new NameTable());
            namespaceManager.AddNamespace("s", Namespaces.S12Namespace);
            namespaceManager.AddNamespace("wsse", Namespaces.Wsse10Namespace);
            namespaceManager.AddNamespace("wsu", Namespaces.WsuNamespace);
            namespaceManager.AddNamespace("wst", Namespaces.Wst13Namespace);
            namespaceManager.AddNamespace("d", Namespaces.SignatureNamespace);
            namespaceManager.AddNamespace("wsa", Namespaces.WsaNamespace);
            return namespaceManager;
        }

        private static void RemoveEndingForwardSlash(XElement element)
        {
            var addressValue = element.Value;
            if (addressValue.EndsWith("/"))
            {
                element.Value = addressValue.Substring(0, addressValue.Length - 1);
            }
        }

        private static XDocument SignMessage(XDocument xDocument, X509Certificate2 clientCertificate)
        {
            // Add id's to elements that needs to be signed.
            XmlNamespaceManager namespaceManager = CreateXmlNamespaceManagerForSigningRequest();

            var actionElement = xDocument.XPathSelectElement("/s:Envelope/s:Header/a:Action", namespaceManager);
            var msgElement = xDocument.XPathSelectElement("/s:Envelope/s:Header/a:MessageID", namespaceManager);
            var toElement = xDocument.XPathSelectElement("/s:Envelope/s:Header/a:To", namespaceManager);
            var timeStampElement = xDocument.XPathSelectElement("/s:Envelope/s:Header/wsse:Security/wsu:Timestamp", namespaceManager);
            var binarySecurityTokenElement = xDocument.XPathSelectElement("/s:Envelope/s:Header/wsse:Security/wsse:BinarySecurityToken", namespaceManager);
            var bodyElement = xDocument.XPathSelectElement("/s:Envelope/s:Body", namespaceManager);

            var idXName = XName.Get("Id", Namespaces.WsuNamespace);
            actionElement.Add(new XAttribute(idXName, IdValue.ActionIdValue));
            msgElement.Add(new XAttribute(idXName, IdValue.MessageIdIdValue));
            toElement.Add(new XAttribute(idXName, IdValue.ToIdValue));
            timeStampElement.Add(new XAttribute(idXName, IdValue.TimeStampIdValue));
            binarySecurityTokenElement.Add(new XAttribute(idXName, IdValue.BinarySecurityTokenIdValue));
            bodyElement.Add(new XAttribute(idXName, IdValue.BodyIdValue));

            var idOfElementsThatMustBeSigned = new List<string>
            {
                IdValue.ActionIdValue,
                IdValue.MessageIdIdValue,
                IdValue.ToIdValue,
                IdValue.TimeStampIdValue,
                IdValue.BinarySecurityTokenIdValue,
                IdValue.BodyIdValue
            };

            xDocument = XmlSignatureUtils.SignDocument(xDocument, idOfElementsThatMustBeSigned, clientCertificate);

            return xDocument;
        }

        private static XmlNamespaceManager CreateXmlNamespaceManagerForSigningRequest()
        {
            var namespaceManager = new XmlNamespaceManager(new NameTable());
            namespaceManager.AddNamespace("a", Namespaces.WsaNamespace);
            namespaceManager.AddNamespace("s", Namespaces.S12Namespace);
            namespaceManager.AddNamespace("wsse", Namespaces.Wsse10Namespace);
            namespaceManager.AddNamespace("wsu", Namespaces.WsuNamespace);
            return namespaceManager;
        }

        private static XElement BuildBinarySecurityTokenElement(X509Certificate2 clientCertificate)
        {
            var binarySecurityTokenElement = new XElement(XName.Get("BinarySecurityToken", Namespaces.Wsse10Namespace));
            binarySecurityTokenElement.Add(new XAttribute("ValueType", Common.X509V3TokenProfile));
            binarySecurityTokenElement.Add(new XAttribute("EncodingType", Common.Base64BinaryEncodingType));
            binarySecurityTokenElement.Value = Convert.ToBase64String(clientCertificate.Export(X509ContentType.Cert));
            return binarySecurityTokenElement;
        }

        private static XElement BuildTimestampElement()
        {
            var createdElement = new XElement(XName.Get("Created", Namespaces.WsuNamespace));
            var currentTime = DateTime.UtcNow;
            createdElement.Value = currentTime.ToString(Common.DateTimeFormat, CultureInfo.InvariantCulture);
            var expiresElement = new XElement(XName.Get("Expires", Namespaces.WsuNamespace));
            expiresElement.Value = currentTime.AddMinutes(5).ToString("s") + "Z"; // Make request expire after 5 minutes.
            var timestampElement = new XElement(XName.Get("Timestamp", Namespaces.WsuNamespace));
            timestampElement.Add(createdElement);
            timestampElement.Add(expiresElement);

            return timestampElement;
        }

        private XElement BuildSecurityElement()
        {
            var securityElement = new XElement(XName.Get("Security", Namespaces.Wsse10Namespace));
            securityElement.Add(new XAttribute(XName.Get("mustUnderstand", Namespaces.S12Namespace), "1"));
            securityElement.Add(BuildTimestampElement());
            securityElement.Add(BuildBinarySecurityTokenElement(_configuration.ClientCertificate));
            return securityElement;
        }
    }
}